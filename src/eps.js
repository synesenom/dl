/**
 * An EPS generator class.
 * @todo make global container of all elements and put them in the right order.
 */
function EPS(boundingBox) {
    // A list of keywords
    var kw = {
        gs: " gsave ",
        gr: " grestore ",
        np: " newpath ",
        lw: " setlinewidth ",
        mt: " moveto ",
        lt: " lineto ",
        c: " setrgbcolor ",
        f: " fill ",
        s: " stroke ",
        a: " arc ",
        cp: " closepath "
    };

    /**
     * An object containing all element of the document:
     * - header
     * - bounding box
     * - styles
     * - drawn elements
     * - eps.footer
     */
    this._doc = {
        by: "",
        bbox: "%%BoundingBox: 0 0 " + boundingBox.width + " " + boundingBox.height + "\n",
        style: {},
        elems: {
            lines: [],
            circles: [],
            polygons: [],
            paths: []
        },
        footer: "\n%%EOF"
    };

    /**
     * Content of the 'Generated by' comment.
     *
     * @param {string} generatedBy Generated by content.
     * @returns {EPS} This EPS object.
     */
    this.by = function(generatedBy) {
        this._doc.by = "\n%Generated by " + generatedBy + "\n";
        return this;
    };

    /*this.style = function(name, values) {
        // Name
        this._doc.style[name] = "/" + name;

        // Single value
        if (values.length == 1) {
            this._doc.style[name] += " " + values[0] + " ";
        } else {
            // Multiple values
            this._doc.style[name] += " [";
            for (var i in values) {
                this._doc.style[name] += " " + values[i];
            }
            this._doc.style[name] += " ]";
        }
        this._doc.style[name] += " def\n";
        return this;
    };*/

    /**
     * Draws a line.
     *
     * @param {object} src Source position, must have x and y keys.
     * @param {object} dst Destination position, must have x and y keys.
     * @param {object} stroke Stroke color, must have r, g and b keys, all values are between 0 and 1.
     * @param {number} width Width of the line.
     * @returns {EPS} This EPS object.
     */
    this.line = function(src, dst, stroke, width) {
        this._doc.elems.lines.push({
            src: src,
            dst: dst,
            stroke: stroke,
            width: width
        });
        return this;
    };

    /**
     * Draws a circle.
     *
     * @param {object} pos Position, must have x and y keys.
     * @param {number} radius Radius.
     * @param {object} fill Fill color, must have r, g and b keys, all values are between 0 and 1.
     * @param {object} stroke Stroke color, must have r, g and b keys, all values are between 0 and 1.
     * @param {number} strokeWidth Width of the stroke around the circle.
     * @returns {EPS} This EPS object.
     */
    this.circle = function(pos, radius, fill, stroke, strokeWidth) {
        this._doc.elems.circles.push({
            pos: pos,
            radius: radius,
            fill: fill,
            stroke: stroke,
            strokeWidth: strokeWidth
        });
        return this;
    };

    /**
     * Draws a polygon.
     *
     * @param {Array} corners Coordinates of the corners, elements must have x and y keys.
     * @param {object} fill Fill color, must have r, g and b keys, all values are between 0 and 1.
     * @param {object} stroke Stroke color, must have r, g and b keys, all values are between 0 and 1.
     * @param {number} strokeWidth Width of the stroke around the polygon.
     * @returns {EPS} This EPS object.
     */
    this.polygon = function(corners, fill, stroke, strokeWidth) {
        this._doc.elems.polygons.push({
            corners: corners,
            fill: fill,
            stroke: stroke,
            strokeWidth: strokeWidth
        });
        return this;
    };

    /**
     * Draws a path.
     *
     * @todo implement filled path
     * @param {Array} segments Coordinates of the segments, elements must have x and y keys.
     * @param {object} fill Fill color, must have r, g and b keys, all values are between 0 and 1.
     * @param {object} stroke Stroke color, must have r, g and b keys, all values are between 0 and 1.
     * @param {number} strokeWidth Width of the path stroke.
     * @returns {EPS} This EPS object.
     */
    this.path = function(segments, fill, stroke, strokeWidth) {
        this._doc.elems.paths.push({
            segments: segments,
            fill: fill,
            stroke: stroke,
            strokeWidth: strokeWidth
        });
    };

    /**
     * Builds the EPS document content.
     *
     * @returns {string} Content of the EPS document.
     */
    this.make = function() {
        // Header
        var doc = "%!PS-Adobe-2.0 EPSF-2.0" + this._doc.by + "\n";
        doc += this._doc.bbox + "\n";

        // Styles
        /*_doc += "%Style\n%\n";
        for (var s in this._doc.style) {
            if (this._doc.style.hasOwnProperty(s)) {
                _doc += this._doc.style[s];
            }
        }
        _doc += "\n";*/

        // Elements
        doc += "\n% Lines\n%\n";
        this._doc.elems.lines.forEach(function(l) {
            doc += kw.gs + kw.np;
            doc += l.stroke.r + " " + l.stroke.g + " " + + l.stroke.b + kw.c;
            doc += l.width + kw.lw;
            doc += l.src.x + " " + l.src.y + kw.mt + l.dst.x + " " + l.dst.y + kw.lt + kw.s;
            doc += kw.gr + "\n";
        });
        doc += "\n% Circles\n%\n";
        this._doc.elems.circles.forEach(function(c) {
            doc += kw.gs + kw.np;
            doc += c.fill.r + " " + c.fill.g + " " + + c.fill.b + kw.c;
            doc += c.pos.x + " " + c.pos.y + " " + c.radius + " 0 360" + kw.a;
            doc += kw.gs + kw.f + kw.gr;
            doc += c.stroke.r + " " + c.stroke.g + " " + + c.stroke.b + kw.c;
            doc += c.strokeWidth + kw.lw + kw.s;
            doc += kw.gr + "\n";
        });
        doc += "\n% Polygons\n%\n";
        this._doc.elems.polygons.forEach(function(p) {
            doc += kw.gs + kw.np;
            doc += p.fill.r + " " + p.fill.g + " " + + p.fill.b + kw.c;
            doc += p.corners[0].x + " " + p.corners[0].y + kw.mt;
            for (var i=1; i<p.corners.length; i++) {
                doc += p.corners[i].x + " " + p.corners[i].y + kw.lt;
            }
            doc += kw.cp;
            doc += kw.gs + kw.f + kw.gr;
            doc += p.stroke.r + " " + p.stroke.g + " " + + p.stroke.b + kw.c;
            doc += p.strokeWidth + kw.lw + kw.s;
            doc += kw.gr + "\n";
        });
        doc += "\n% Paths\n%\n";
        this._doc.elems.paths.forEach(function(p) {
            doc += kw.gs + kw.np;
            doc += p.stroke.r + " " + p.stroke.g + " " + + p.stroke.b + kw.c;
            doc += p.strokeWidth + kw.lw + kw.f;
            doc += p.segments[0].x + " " + p.segments[0].y + kw.mt;
            for (var i=1; i<p.segments.length; i++) {
                doc += p.segments[i].x + " " + p.segments[i].y + kw.lt;
            }
            doc += kw.s + kw.gr + "\n";
        });

        // Footer
        doc += this._doc.footer;
        return doc.replace(/  +/g, " ").replace(/\n /g, "\n");
    };
}